import streamlit as st
import pandas as pd
import pymysql

# Function to establish database connection
def get_db_connection():
    return pymysql.connect(
        host="localhost",
        user="root",
        password="Umaneethi@123",
        database="zomato_deliveries",
        autocommit=True
    )

# CRUD SQL Queries
CREATE_TABLE_QUERY = """
    CREATE TABLE IF NOT EXISTS zomato_samples (
        name VARCHAR(100),
        age INT,
        rating FLOAT
    )
"""
READ_QUERY = "SELECT * FROM deliveries_data"
INSERT_QUERY = "INSERT INTO deliveries_data (Name, Order_ID, Rating, Status) VALUES (%s, %s, %s, %s)"
UPDATE_QUERY = "UPDATE deliveries_data SET Rating = %s, Status = %s WHERE Order_ID = %s"
DELETE_QUERY = "DELETE FROM deliveries_data WHERE Order_ID = %s"


# SQL Query Dictionary
queries = {
    "Find the top 5 customers who placed the most orders.": """
        SELECT c.customer_id, c.name, COUNT(o.order_id) AS total_orders 
        FROM Customers c
        JOIN Orders o ON c.customer_id = o.customer_id 
        GROUP BY c.customer_id, c.name 
        ORDER BY total_orders DESC 
        LIMIT 5;
    """,
    "Find the most popular cuisine type among premium customers.": """
        SELECT preferred_cuisine, COUNT(*) AS count 
        FROM Customers 
        WHERE is_premium = 1 
        GROUP BY preferred_cuisine 
        ORDER BY count DESC 
        LIMIT 1;
    """,
    "Find the top 3 highest-rated restaurants.": """
        SELECT name, rating 
        FROM Restaurants 
        ORDER BY rating DESC 
        LIMIT 3;
    """,
    "Find the top 5 customers who have spent the most money.": """
        SELECT c.customer_id, c.name, SUM(o.total_amount) AS total_spent
        FROM Orders o
        JOIN Customers c ON o.customer_id = c.customer_id
        GROUP BY c.customer_id, c.name
        ORDER BY total_spent DESC
        LIMIT 5;
    """,
    "Find the number of orders per payment mode.": """
        SELECT payment_mode, COUNT(*) AS total_orders 
        FROM Orders 
        GROUP BY payment_mode;
    """,
    "Identify customers who have not placed any orders.": """
        SELECT c.customer_id, c.name 
        FROM Customers c 
        LEFT JOIN Orders o ON c.customer_id = o.customer_id 
        WHERE o.order_id IS NULL;
    """,
    "Find the most common delivery status.": """
        SELECT delivery_status, COUNT(*) AS count 
        FROM Deliveries 
        GROUP BY delivery_status 
        ORDER BY count DESC 
        LIMIT 1;
    """,
    "Find the top 3 most frequent customers (by order count).": """
        SELECT c.customer_id, c.name, COUNT(o.order_id) AS total_orders
        FROM Customers c
        JOIN Orders o ON c.customer_id = o.customer_id
        GROUP BY c.customer_id, c.name
        ORDER BY total_orders DESC
        LIMIT 3;
    """,
    "Identify the busiest delivery person.": """
        SELECT d.delivery_person_id, d.name, COUNT(*) AS total_deliveries 
        FROM Deliveries del
        JOIN DeliveryPersons d ON del.delivery_person_id = d.delivery_person_id
        GROUP BY d.delivery_person_id, d.name 
        ORDER BY total_deliveries DESC 
        LIMIT 1;
    """,
    "Find the restaurant with the best average feedback rating.": """
        SELECT r.name, AVG(o.feedback_rating) AS avg_rating
        FROM Orders o
        JOIN Restaurants r ON o.restaurant_id = r.restaurant_id
        GROUP BY r.name
        ORDER BY avg_rating DESC
        LIMIT 1;
    """,
    "Find the highest-rated delivery person.": """
        SELECT name, average_rating 
        FROM DeliveryPersons 
        ORDER BY average_rating DESC 
        LIMIT 1;
    """,
    "Identify the average discount applied per order.": """
        SELECT AVG(discount_applied) AS avg_discount 
        FROM Orders;
    """,
    "Find the total revenue generated by each payment mode.": """
        SELECT payment_mode, SUM(total_amount) AS total_revenue
        FROM Orders
        GROUP BY payment_mode
        ORDER BY total_revenue DESC;
    """,
    "Find the delivery person who has delivered the most orders.": """
        SELECT d.delivery_person_id, d.name, COUNT(del.delivery_id) AS total_deliveries
        FROM Deliveries del
        JOIN DeliveryPersons d ON del.delivery_person_id = d.delivery_person_id
        GROUP BY d.delivery_person_id, d.name
        ORDER BY total_deliveries DESC
        LIMIT 1;
    """,
    "Identify customers who have placed orders at more than 3 different restaurants.": """
        SELECT c.customer_id, c.name, COUNT(DISTINCT o.restaurant_id) AS unique_restaurants 
        FROM Orders o
        JOIN Customers c ON o.customer_id = c.customer_id
        GROUP BY c.customer_id, c.name 
        HAVING unique_restaurants > 3;
    """,
    "Find the busiest time period (hour) for order placements.": """
        SELECT HOUR(order_date) AS order_hour, COUNT(*) AS order_count 
        FROM Orders 
        GROUP BY order_hour 
        ORDER BY order_count DESC 
        LIMIT 1;
    """,
    "Find customers who have given an average rating above 4.5.": """
        SELECT c.name, AVG(o.feedback_rating) AS avg_rating 
        FROM Orders o
        JOIN Customers c ON o.customer_id = c.customer_id
        GROUP BY c.name 
        HAVING avg_rating > 4.5;
    """,
    "Calculate total revenue per restaurant.": """
        SELECT r.name, SUM(o.total_amount) AS total_revenue 
        FROM Orders o
        JOIN Restaurants r ON o.restaurant_id = r.restaurant_id
        GROUP BY r.name 
        ORDER BY total_revenue DESC;
    """,
    "Find the restaurant with the highest repeat customer rate.": """
        SELECT r.name, 
               COUNT(o.customer_id) AS total_orders, 
               COUNT(DISTINCT o.customer_id) AS unique_customers,
               (COUNT(o.customer_id) / COUNT(DISTINCT o.customer_id)) AS repeat_rate
        FROM Orders o
        JOIN Restaurants r ON o.restaurant_id = r.restaurant_id
        GROUP BY r.name
        ORDER BY repeat_rate DESC
        LIMIT 1;
    """
}

# Function to execute queries
def execute_query(query, params=()):
    conn = None
    cursor = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute(query, params)

        if query.strip().upper().startswith("SELECT"):
            data = cursor.fetchall()
            columns = [desc[0] for desc in cursor.description] if data else []
            return pd.DataFrame(data, columns=columns)

        conn.commit()
        return None

    except pymysql.MySQLError as e:
        st.error(f"Error executing query: {e}")
        return None

    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()

# Streamlit Layout
st.set_page_config(layout="wide", page_title="Zomato Deliveries Dashboard")
st.image("C:\\Users\\neeth\\Downloads\\DALL¬∑E 2025-02-23 11.11.13 - A realistic scene of a Zomato delivery person riding a motorbike with a red Zomato-branded delivery bag through a busy city street. The background inc.jpg",width=350)

st.title("üçî Zomato Deliveries Dashboard üçï")


# Sidebar for operation type
option_type = st.sidebar.radio("Select Operation Type", ["SQL Queries", "CRUD Operations"])

# SQL Query Execution
if option_type == "SQL Queries":
    selected_query = st.sidebar.selectbox("üîç Choose a Query:", list(queries.keys()))
    if st.sidebar.button("Run Query"):
        query = queries[selected_query]
        df = execute_query(query)
        st.subheader("üîç Selected Query:")
        st.write(f"**{selected_query}**")

        if df is not None and not df.empty:
            st.dataframe(df)

            # Debugging: Print column names
            st.write("üìä **Returned Columns:**", df.columns.tolist())

            # Ensure a numeric column is available for the bar chart
            numeric_columns = df.select_dtypes(include=['int64', 'float64']).columns.tolist()
            non_numeric_columns = [col for col in df.columns if col not in numeric_columns]

            if numeric_columns and non_numeric_columns:
                # Automatically select the first non-numeric column as the index
                index_column = non_numeric_columns[0]  # Select first non-numeric column safely

                # Debugging: Print selected index and numeric columns
                st.write(f"üìå **Using '{index_column}' as index for bar chart**")
                st.write(f"üìà **Numeric Columns:** {numeric_columns}")

                # Plot the bar chart
                st.bar_chart(df.set_index(index_column)[numeric_columns])
            elif numeric_columns:
                st.warning("No non-numeric columns available to use as an index for the bar chart.")
            else:
                st.warning("No numeric data available for visualization.")
        else:
            st.warning("No data to display.")
        
        st.write("üìå SQL Query:")
        st.code(query, language="sql")

# CRUD Operations
if option_type == "CRUD Operations":
    crud_operation = st.sidebar.selectbox("Select CRUD Operation", ["Create", "Insert", "Read", "Update", "Delete"])

    if crud_operation == "Create":
        st.info("The reference table `deliveries_data` is already created. You can now insert records.")

    elif crud_operation == "Insert":
        st.subheader("Insert New Record")
        name = st.text_input("Enter Name")
        order_id = st.number_input("Enter Order ID", min_value=0, step=1)
        rating = st.number_input("Enter Rating", min_value=0.0, max_value=5.0, step=0.1)
        status = st.selectbox("Select Status", ["Delivered", "Pending", "Cancelled"])

        if st.button("Insert Record"):
            if name and order_id:
                execute_query(INSERT_QUERY, (name, order_id, rating, status))
                st.success("Record Inserted Successfully!")
            else:
                st.warning("Name and Order ID cannot be empty.")

    elif crud_operation == "Read":
        if st.sidebar.button("Read Data"):
            data = execute_query(READ_QUERY)
            if data is not None and not data.empty:
                st.write(data)
            else:
                st.warning("No records found.")

    elif crud_operation == "Update":
        st.subheader("Update Record")
        order_id_to_update = st.number_input("Enter Order ID to Update", min_value=0, step=1)
        new_rating = st.number_input("Enter New Rating", min_value=0.0, max_value=5.0, step=0.1)
        new_status = st.selectbox("Select New Status", ["Delivered", "Pending", "Cancelled"])

        if st.button("Update Record"):
            execute_query(UPDATE_QUERY, (new_rating, new_status, order_id_to_update))
            st.success("Record Updated Successfully!")

    elif crud_operation == "Delete":
        st.subheader("Delete Record")
        order_id_to_delete = st.number_input("Enter Order ID to Delete", min_value=0, step=1)

        if st.button("Delete Record"):
            execute_query(DELETE_QUERY, (order_id_to_delete,))
            st.success("Record Deleted Successfully!")
